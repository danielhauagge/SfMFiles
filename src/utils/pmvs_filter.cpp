// Copyright (C) 2013 by Daniel Hauagge
//
// Permission is hereby granted, free  of charge, to any person obtaining
// a  copy  of this  software  and  associated  documentation files  (the
// "Software"), to  deal in  the Software without  restriction, including
// without limitation  the rights to  use, copy, modify,  merge, publish,
// distribute,  sublicense, and/or sell  copies of  the Software,  and to
// permit persons to whom the Software  is furnished to do so, subject to
// the following conditions:
//
// The  above  copyright  notice  and  this permission  notice  shall  be
// included in all copies or substantial portions of the Software.
//
// THE  SOFTWARE IS  PROVIDED  "AS  IS", WITHOUT  WARRANTY  OF ANY  KIND,
// EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF
// MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#include <SfMFiles/sfmfiles>

#include <CMDCore/optparser>

#include <iostream>

// http://stackoverflow.com/questions/10051679/c-tokenize-string
std::vector<std::string> inline
splitString(const std::string& source, const char* delimiter = " ", bool keepEmpty = false)
{
    std::vector<std::string> results;

    size_t prev = 0;
    size_t next = 0;

    while ((next = source.find_first_of(delimiter, prev)) != std::string::npos) {
        if (keepEmpty || (next - prev != 0)) {
            results.push_back(source.substr(prev, next - prev));
        }
        prev = next + 1;
    }

    if (prev < source.size()) {
        results.push_back(source.substr(prev));
    }

    return results;
}

int
main(int argc, const char* argv[])
{
    using namespace BDATA;
    using namespace cmdc;

    OptionParser::Arguments args;
    OptionParser::Options opts;

    OptionParser optParser(&args, &opts);
    optParser.addUsage("<in:old.patch> <out:new.patch>");
    optParser.addDescription("Utility that provides multiple ways of "
                             "filtering .patch files generated by PMVS.");
    optParser.addOption("subsampleFraction", "", "F", "--subsample-fraction",
                        "Keeps only a fraction of the points (controlled by the parameter F, if 1 "
                        "then keeps all points) [default = %default]", "0.1");
    optParser.addOption("boundingSphere", "", "S", "--bounding-sphere",
                        "Keep all points that fall within a bounding sphere. Specify as X,Y,Z,R where "
                        "X, Y, and Z are center coordinates and R is the radius.");
    optParser.addFlag("dontLoadOption", "-p", "--dont-load-options",
                      "Do not try to load options file for the reconstruction (used to remap"
                      " camera indexes)");
    optParser.parse(argc, argv);

    std::string inPmvsFName = args[0];
    std::string outPmvsFName = args[1];

    float frac = opts["subsampleFraction"].asFloat();

    bool tryLoadOptions = !opts["dontLoadOption"].asBool();

    bool useBoundingSphere = 0;
    Eigen::Vector4d spherePos;
    float sphereRadius = 0;
    if(opts.count("boundingSphere") != 0) {
        useBoundingSphere = 1;

        std::vector<std::string> tokens = splitString(opts["boundingSphere"], ",");

        if(tokens.size() != 4) {
            std::cout << "ERROR: Cannot parse bounding sphere parameters, wrong number of values = " << tokens.size() << ", should be 4" << std::endl;
            return EXIT_FAILURE;
        }

        for(int i = 0; i < 3; i++) {
            spherePos[i] = atof(tokens[i].c_str());
        }
        spherePos[3] = 1;

        sphereRadius = atof(tokens[3].c_str());
    }

    // Loading data
    PMVS::PMVSData pmvs(inPmvsFName.c_str(), tryLoadOptions);
    PMVS::PMVSData pmvsFiltered;

    int nOutsideSphere = 0, nDiscardedSampling = 0;

    LOG_INFO("Processing data");
    PMVS::Patch::Vector& patchFiltered = pmvsFiltered.getPatches();
    for(int i = 0; i < pmvs.getNPatches(); i++) {
        //if(i%1000 == 0) {
        //  LOG_INFO(i << "/" << pmvs.getNPatches());
        //}

        if(useBoundingSphere) {
            double d = (pmvs.getPatches()[i].position - spherePos).norm();
            if(d > sphereRadius) {
                nOutsideSphere++;
                continue;
            }
        }

        double prob = rand() / (RAND_MAX + 1.0);

        if(prob <= frac) {
            patchFiltered.push_back(pmvs.getPatches()[i]);
        } else {
            nDiscardedSampling++;
        }
    }

    LOG_INFO(nOutsideSphere << " points discarded because they were outside the bounding sphere");
    LOG_INFO(nDiscardedSampling << " points discarded by sampling");
    LOG_INFO(patchFiltered.size() << "/" << pmvs.getNPatches() << " points kept");

    pmvsFiltered.writeFile(outPmvsFName.c_str());



    return EXIT_SUCCESS;
}
