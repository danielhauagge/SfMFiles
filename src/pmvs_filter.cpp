#include <SfMFiles/sfmfiles>

#include <OptParser/optparser>

#include <iostream>

#define PRINT_MSG(msg) std::cout << ">> " << msg << std::endl

// http://stackoverflow.com/questions/10051679/c-tokenize-string
std::vector<std::string> inline 
splitString(const std::string &source, const char *delimiter = " ", bool keepEmpty = false)
{
  std::vector<std::string> results;

  size_t prev = 0;
  size_t next = 0;

  while ((next = source.find_first_of(delimiter, prev)) != std::string::npos) {
    if (keepEmpty || (next - prev != 0)) {
      results.push_back(source.substr(prev, next - prev));
    }
    prev = next + 1;
  }

  if (prev < source.size()) {
    results.push_back(source.substr(prev));
  }
  
  return results;
}

int
main(int argc, const char* argv[])
{
  using namespace BDATA;

  std::vector<std::string> args;
  std::map<std::string, std::string> opts;

  OptionParser optParser(&args, &opts);
  optParser.addUsage("[OPTIONS] <in:old.patch> <out:new.patch>");
  optParser.addDescription("Utility that provides multiple ways of filtering .patch files generated by PMVS.");
  
  optParser.addOption("subsampleFraction", "", "F", "--subsample-fraction", "Keeps only a fraction of the points (controlled by the parameter F, if 1 then keeps all points) [default = %default]", "1");
  optParser.addOption("boundingSphere", "", "S", "--bounding-sphere", "Keep all points that fall within a bounding sphere. Specify as X,Y,Z,R where X, Y, and Z are center coordinates and R is the radius.");
  optParser.addFlag("dontLoadOption", "-p", "--dont-load-options", "Do not try to load options file for the reconstruction (used to remap camera indexes)");      
  optParser.parse(argc, argv);

  std::string inPmvsFName = args[0];
  std::string outPmvsFName = args[1];
	
  float frac = atof(opts["subsampleFraction"].c_str());

  bool tryLoadOptions = !atoi(opts["dontLoadOption"].c_str());

  bool useBoundingSphere = 0;
  Eigen::Vector4d spherePos;
  float sphereRadius = 0;
  if(opts.count("boundingSphere") != 0) {
    useBoundingSphere = 1;

    std::vector<std::string> tokens = splitString(opts["boundingSphere"], ",");
    
    if(tokens.size() != 4) {
      std::cout << "ERROR: Cannot parse bounding sphere parameters, wrong number of values = " << tokens.size() << ", should be 4" << std::endl;
      return EXIT_FAILURE;
    }

    for(int i = 0; i < 3; i++) {
      spherePos[i] = atof(tokens[i].c_str());
    }
    spherePos[3] = 1;

    sphereRadius = atof(tokens[3].c_str());
  }

  // Loading data
  PMVS::PMVSData pmvs(inPmvsFName.c_str(), tryLoadOptions);
  PMVS::PMVSData pmvsFiltered;
  
  int nOutsideSphere = 0, nDiscardedSampling = 0;

  PRINT_MSG("Processing data");
  PMVS::Patch::Vector& patchFiltered = pmvsFiltered.getPatches();
  for(int i = 0; i < pmvs.getNPatches(); i++) {
    //if(i%1000 == 0) {
    //  PRINT_MSG(i << "/" << pmvs.getNPatches());
    //}

    if(useBoundingSphere) {
      double d = (pmvs.getPatches()[i].position - spherePos).norm();
      if(d > sphereRadius) {
	nOutsideSphere++;
	continue;
      }
    }

    double prob = rand() / (RAND_MAX + 1.0);

    if(prob <= frac) {
      patchFiltered.push_back(pmvs.getPatches()[i]);
    } else {
      nDiscardedSampling++;
    }
  }
  
  PRINT_MSG(nOutsideSphere << " points discarded because they were outside the bounding sphere");
  PRINT_MSG(nDiscardedSampling << " points discarded by sampling");
  PRINT_MSG(patchFiltered.size() << "/" << pmvs.getNPatches() << " points kept");

  pmvsFiltered.writeFile(outPmvsFName.c_str());

  return EXIT_SUCCESS;
}
